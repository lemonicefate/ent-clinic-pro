name: 自動化品質檢查

on:
  pull_request:
    branches: [ main, master ]
    paths:
      - 'src/content/**'
      - 'public/admin/**'
      - 'src/**'
  push:
    branches: [ main, master ]
    paths:
      - 'src/content/**'
      - 'public/admin/**'
  schedule:
    # 每日凌晨 2 點執行完整檢查
    - cron: '0 2 * * *'

jobs:
  # 程式碼品質檢查
  code-quality:
    runs-on: ubuntu-latest
    name: 程式碼品質檢查
    
    steps:
    - name: 檢出程式碼
      uses: actions/checkout@v4
      
    - name: 設定 Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: 安裝依賴
      run: npm ci
      
    - name: ESLint 檢查
      run: |
        if [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] || [ -f "eslint.config.js" ]; then
          echo "執行 ESLint 檢查..."
          npx eslint src/ --ext .js,.ts,.astro --format=compact || true
        else
          echo "未找到 ESLint 配置，跳過檢查"
        fi
        
    - name: TypeScript 類型檢查
      run: |
        if [ -f "tsconfig.json" ]; then
          echo "執行 TypeScript 類型檢查..."
          npx tsc --noEmit || true
        else
          echo "未找到 TypeScript 配置，跳過檢查"
        fi
        
    - name: Astro 檢查
      run: |
        echo "執行 Astro 檢查..."
        npm run astro check || true

  # 安全性掃描
  security-scan:
    runs-on: ubuntu-latest
    name: 安全性掃描
    
    steps:
    - name: 檢出程式碼
      uses: actions/checkout@v4
      
    - name: 設定 Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: 安裝依賴
      run: npm ci
      
    - name: npm audit 安全檢查
      run: |
        echo "執行 npm audit 安全檢查..."
        npm audit --audit-level=moderate || true
        
    - name: 檢查敏感檔案
      run: |
        echo "檢查敏感檔案和資訊..."
        
        # 檢查是否有敏感檔案
        sensitive_files=(
          ".env"
          ".env.local"
          ".env.production"
          "config/database.yml"
          "config/secrets.yml"
          "private.key"
          "*.pem"
          "*.p12"
          "*.pfx"
        )
        
        found_sensitive=false
        for pattern in "${sensitive_files[@]}"; do
          if find . -name "$pattern" -not -path "./node_modules/*" | grep -q .; then
            echo "⚠️ 發現敏感檔案: $pattern"
            found_sensitive=true
          fi
        done
        
        if [ "$found_sensitive" = false ]; then
          echo "✅ 未發現敏感檔案"
        fi
        
    - name: 檢查硬編碼密鑰
      run: |
        echo "檢查硬編碼密鑰和敏感資訊..."
        
        # 檢查常見的敏感資訊模式
        patterns=(
          "password\s*=\s*['\"][^'\"]{8,}"
          "api[_-]?key\s*=\s*['\"][^'\"]{16,}"
          "secret\s*=\s*['\"][^'\"]{16,}"
          "token\s*=\s*['\"][^'\"]{20,}"
          "AKIA[0-9A-Z]{16}"  # AWS Access Key
          "sk_live_[0-9a-zA-Z]{24}"  # Stripe Live Key
        )
        
        found_secrets=false
        for pattern in "${patterns[@]}"; do
          if grep -r -E "$pattern" src/ public/ --exclude-dir=node_modules 2>/dev/null; then
            echo "⚠️ 可能發現硬編碼敏感資訊"
            found_secrets=true
          fi
        done
        
        if [ "$found_secrets" = false ]; then
          echo "✅ 未發現硬編碼敏感資訊"
        fi

  # 效能檢查
  performance-check:
    runs-on: ubuntu-latest
    name: 效能檢查
    
    steps:
    - name: 檢出程式碼
      uses: actions/checkout@v4
      
    - name: 設定 Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: 安裝依賴
      run: npm ci
      
    - name: 建置專案
      run: npm run build
      
    - name: 分析建置大小
      run: |
        echo "分析建置檔案大小..."
        
        if [ -d "dist" ]; then
          echo "📊 建置檔案大小分析:"
          
          # 總大小
          total_size=$(du -sh dist | cut -f1)
          echo "總建置大小: $total_size"
          
          # JavaScript 檔案
          js_size=$(find dist -name "*.js" -exec du -ch {} + 2>/dev/null | tail -1 | cut -f1 || echo "0")
          echo "JavaScript 檔案: $js_size"
          
          # CSS 檔案
          css_size=$(find dist -name "*.css" -exec du -ch {} + 2>/dev/null | tail -1 | cut -f1 || echo "0")
          echo "CSS 檔案: $css_size"
          
          # 圖片檔案
          img_size=$(find dist -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.webp" -o -name "*.svg" -exec du -ch {} + 2>/dev/null | tail -1 | cut -f1 || echo "0")
          echo "圖片檔案: $img_size"
          
          # 檢查大檔案
          echo ""
          echo "🔍 大於 1MB 的檔案:"
          find dist -type f -size +1M -exec ls -lh {} \; | awk '{print $5, $9}' || echo "無大檔案"
          
          # 檢查未壓縮的檔案
          echo ""
          echo "🗜️ 建議壓縮的檔案類型:"
          find dist -name "*.js" -o -name "*.css" -o -name "*.html" | head -10 | while read file; do
            size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
            if [ "$size" -gt 10240 ]; then  # 大於 10KB
              echo "  $file ($(du -h "$file" | cut -f1))"
            fi
          done
        else
          echo "❌ 建置目錄不存在"
        fi
        
    - name: 檢查圖片優化
      run: |
        echo "檢查圖片優化..."
        
        # 檢查大圖片檔案
        echo "🖼️ 檢查大圖片檔案 (>500KB):"
        find src/content public/images -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" 2>/dev/null | while read file; do
          if [ -f "$file" ]; then
            size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
            if [ "$size" -gt 512000 ]; then  # 大於 500KB
              size_mb=$(echo "scale=2; $size/1024/1024" | bc -l 2>/dev/null || echo "unknown")
              echo "  ⚠️ $file (${size_mb}MB)"
            fi
          fi
        done
        
        # 檢查是否使用現代圖片格式
        echo ""
        echo "📸 圖片格式建議:"
        old_format_count=$(find src/content public/images -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" 2>/dev/null | wc -l)
        webp_count=$(find src/content public/images -name "*.webp" 2>/dev/null | wc -l)
        avif_count=$(find src/content public/images -name "*.avif" 2>/dev/null | wc -l)
        
        echo "  傳統格式 (JPG/PNG): $old_format_count 個檔案"
        echo "  WebP 格式: $webp_count 個檔案"
        echo "  AVIF 格式: $avif_count 個檔案"
        
        if [ "$old_format_count" -gt 0 ] && [ "$webp_count" -eq 0 ]; then
          echo "  💡 建議使用 WebP 格式以提升載入速度"
        fi

  # 內容品質監控
  content-quality-monitoring:
    runs-on: ubuntu-latest
    name: 內容品質監控
    if: github.event_name == 'schedule'
    
    steps:
    - name: 檢出程式碼
      uses: actions/checkout@v4
      
    - name: 設定 Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: 內容統計分析
      run: |
        echo "執行內容品質監控..."
        
        cat > content-monitoring.js << 'EOF'
        const fs = require('fs');
        const path = require('path');
        const yaml = require('js-yaml');
        
        function generateContentReport() {
          const educationDir = 'src/content/education';
          
          if (!fs.existsSync(educationDir)) {
            console.log('教育內容目錄不存在');
            return;
          }
          
          const files = fs.readdirSync(educationDir, { recursive: true })
            .filter(file => file.endsWith('.md'))
            .map(file => path.join(educationDir, file));
          
          const stats = {
            totalArticles: files.length,
            bySpecialty: {},
            byStatus: {},
            byAuthor: {},
            avgWordCount: 0,
            recentUpdates: [],
            qualityIssues: []
          };
          
          let totalWords = 0;
          const now = new Date();
          const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          
          for (const file of files) {
            try {
              const content = fs.readFileSync(file, 'utf8');
              const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
              
              if (!frontmatterMatch) continue;
              
              const frontmatter = yaml.load(frontmatterMatch[1]);
              const bodyContent = content.replace(/^---\n[\s\S]*?\n---\n/, '');
              const wordCount = bodyContent.split(/\s+/).length;
              
              totalWords += wordCount;
              
              // 統計專科分布
              const specialty = frontmatter.specialty || 'unknown';
              stats.bySpecialty[specialty] = (stats.bySpecialty[specialty] || 0) + 1;
              
              // 統計狀態分布
              const status = frontmatter.status || 'unknown';
              stats.byStatus[status] = (stats.byStatus[status] || 0) + 1;
              
              // 統計作者分布
              const author = frontmatter.author || 'unknown';
              stats.byAuthor[author] = (stats.byAuthor[author] || 0) + 1;
              
              // 檢查最近更新
              const publishDate = new Date(frontmatter.publishDate);
              if (publishDate > oneWeekAgo) {
                stats.recentUpdates.push({
                  file: file,
                  title: frontmatter.title,
                  date: publishDate.toISOString().split('T')[0]
                });
              }
              
              // 品質問題檢查
              if (wordCount < 200) {
                stats.qualityIssues.push({
                  file: file,
                  issue: `內容過短 (${wordCount} 字)`,
                  severity: 'warning'
                });
              }
              
              if (!frontmatter.description || frontmatter.description.length < 50) {
                stats.qualityIssues.push({
                  file: file,
                  issue: '描述過短或缺失',
                  severity: 'warning'
                });
              }
              
              if (!frontmatter.tags || frontmatter.tags.length === 0) {
                stats.qualityIssues.push({
                  file: file,
                  issue: '缺少標籤',
                  severity: 'info'
                });
              }
              
            } catch (error) {
              stats.qualityIssues.push({
                file: file,
                issue: `檔案解析錯誤: ${error.message}`,
                severity: 'error'
              });
            }
          }
          
          stats.avgWordCount = Math.round(totalWords / files.length);
          
          // 生成報告
          console.log('📊 內容品質監控報告');
          console.log('='.repeat(50));
          console.log(`總文章數: ${stats.totalArticles}`);
          console.log(`平均字數: ${stats.avgWordCount}`);
          console.log('');
          
          console.log('📈 專科分布:');
          Object.entries(stats.bySpecialty)
            .sort(([,a], [,b]) => b - a)
            .forEach(([specialty, count]) => {
              console.log(`  ${specialty}: ${count} 篇`);
            });
          console.log('');
          
          console.log('📋 狀態分布:');
          Object.entries(stats.byStatus)
            .forEach(([status, count]) => {
              console.log(`  ${status}: ${count} 篇`);
            });
          console.log('');
          
          console.log('👥 作者分布:');
          Object.entries(stats.byAuthor)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10)
            .forEach(([author, count]) => {
              console.log(`  ${author}: ${count} 篇`);
            });
          console.log('');
          
          console.log('🆕 最近更新 (7天內):');
          stats.recentUpdates
            .sort((a, b) => new Date(b.date) - new Date(a.date))
            .slice(0, 10)
            .forEach(update => {
              console.log(`  ${update.date}: ${update.title}`);
            });
          console.log('');
          
          console.log('⚠️ 品質問題:');
          const errorCount = stats.qualityIssues.filter(i => i.severity === 'error').length;
          const warningCount = stats.qualityIssues.filter(i => i.severity === 'warning').length;
          const infoCount = stats.qualityIssues.filter(i => i.severity === 'info').length;
          
          console.log(`  錯誤: ${errorCount} 個`);
          console.log(`  警告: ${warningCount} 個`);
          console.log(`  資訊: ${infoCount} 個`);
          
          if (stats.qualityIssues.length > 0) {
            console.log('');
            console.log('詳細問題列表:');
            stats.qualityIssues.slice(0, 20).forEach(issue => {
              const icon = issue.severity === 'error' ? '❌' : 
                          issue.severity === 'warning' ? '⚠️' : 'ℹ️';
              console.log(`  ${icon} ${issue.file}: ${issue.issue}`);
            });
            
            if (stats.qualityIssues.length > 20) {
              console.log(`  ... 還有 ${stats.qualityIssues.length - 20} 個問題`);
            }
          }
          
          // 生成 JSON 報告
          const report = {
            generatedAt: new Date().toISOString(),
            stats: stats
          };
          
          fs.writeFileSync('content-quality-report.json', JSON.stringify(report, null, 2));
          console.log('\n📄 詳細報告已儲存至 content-quality-report.json');
        }
        
        generateContentReport();
        EOF
        
        node content-monitoring.js
        
    - name: 上傳品質報告
      uses: actions/upload-artifact@v4
      with:
        name: content-quality-report
        path: content-quality-report.json
        retention-days: 30

  # 依賴更新檢查
  dependency-check:
    runs-on: ubuntu-latest
    name: 依賴更新檢查
    if: github.event_name == 'schedule'
    
    steps:
    - name: 檢出程式碼
      uses: actions/checkout@v4
      
    - name: 設定 Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: 檢查過期依賴
      run: |
        echo "檢查過期依賴..."
        
        # 檢查過期的 npm 套件
        echo "📦 檢查 npm 套件更新:"
        npm outdated || true
        
        echo ""
        echo "🔒 檢查安全漏洞:"
        npm audit || true
        
        echo ""
        echo "📊 依賴分析:"
        
        # 分析 package.json
        if [ -f "package.json" ]; then
          deps_count=$(jq '.dependencies | length' package.json 2>/dev/null || echo "0")
          dev_deps_count=$(jq '.devDependencies | length' package.json 2>/dev/null || echo "0")
          
          echo "  生產依賴: $deps_count 個"
          echo "  開發依賴: $dev_deps_count 個"
          
          # 檢查大型依賴
          echo ""
          echo "📈 套件大小分析:"
          if command -v npx >/dev/null 2>&1; then
            npx cost-of-modules --no-install 2>/dev/null | head -10 || echo "  無法分析套件大小"
          fi
        fi

  # 綜合報告
  generate-quality-report:
    runs-on: ubuntu-latest
    name: 生成品質報告
    needs: [code-quality, security-scan, performance-check, content-quality-monitoring, dependency-check]
    if: always()
    
    steps:
    - name: 檢出程式碼
      uses: actions/checkout@v4
      
    - name: 生成綜合品質報告
      run: |
        echo "生成綜合品質報告..."
        
        cat > quality-report.md << 'EOF'
        # 自動化品質檢查報告
        
        **生成時間**: $(date)
        **提交**: ${{ github.sha }}
        **分支**: ${{ github.ref_name }}
        **觸發事件**: ${{ github.event_name }}
        
        ## 檢查結果摘要
        
        | 檢查項目 | 狀態 | 說明 |
        |---------|------|------|
        | 程式碼品質檢查 | ${{ needs.code-quality.result == 'success' && '✅ 通過' || needs.code-quality.result == 'skipped' && '⏭️ 跳過' || '❌ 失敗' }} | ESLint, TypeScript, Astro 檢查 |
        | 安全性掃描 | ${{ needs.security-scan.result == 'success' && '✅ 通過' || needs.security-scan.result == 'skipped' && '⏭️ 跳過' || '❌ 失敗' }} | 依賴漏洞、敏感資訊檢查 |
        | 效能檢查 | ${{ needs.performance-check.result == 'success' && '✅ 通過' || needs.performance-check.result == 'skipped' && '⏭️ 跳過' || '❌ 失敗' }} | 建置大小、圖片優化分析 |
        | 內容品質監控 | ${{ needs.content-quality-monitoring.result == 'success' && '✅ 通過' || needs.content-quality-monitoring.result == 'skipped' && '⏭️ 跳過' || '❌ 失敗' }} | 內容統計、品質問題檢查 |
        | 依賴更新檢查 | ${{ needs.dependency-check.result == 'success' && '✅ 通過' || needs.dependency-check.result == 'skipped' && '⏭️ 跳過' || '❌ 失敗' }} | 過期依賴、安全漏洞檢查 |
        
        ## 品質指標
        
        ### 程式碼品質
        - **ESLint**: 檢查 JavaScript/TypeScript 程式碼規範
        - **TypeScript**: 類型安全檢查
        - **Astro**: 框架特定檢查
        
        ### 安全性
        - **依賴掃描**: 檢查已知安全漏洞
        - **敏感資訊**: 防止密鑰洩露
        - **檔案安全**: 檢查敏感檔案
        
        ### 效能
        - **建置大小**: 監控輸出檔案大小
        - **圖片優化**: 檢查圖片格式和大小
        - **資源分析**: 識別效能瓶頸
        
        ### 內容品質
        - **內容統計**: 文章數量、字數分析
        - **品質檢查**: 結構、格式、完整性
        - **更新追蹤**: 最近修改內容
        
        ## 建議改善事項
        
        根據檢查結果，建議關注以下方面：
        
        1. **程式碼品質**: 修復 ESLint 和 TypeScript 錯誤
        2. **安全性**: 更新有漏洞的依賴套件
        3. **效能**: 優化大檔案和圖片
        4. **內容**: 改善品質問題較多的文章
        
        ## 自動化改善
        
        系統會自動執行以下改善措施：
        - 定期掃描安全漏洞
        - 監控內容品質趨勢
        - 追蹤效能指標變化
        - 生成改善建議
        
        ---
        
        *此報告由 GitHub Actions 自動生成，每日更新*
        EOF
        
        echo "品質報告已生成"
        
    - name: 上傳品質報告
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: quality-report
        path: quality-report.md
        retention-days: 30
        
    - name: 通知品質狀態
      if: failure()
      run: |
        echo "⚠️ 品質檢查發現問題，請查看詳細報告"
        echo "📋 可在 Actions 頁面下載完整報告"