# ç®¡ç†è€…æ‰‹å†Š

## ç³»çµ±ç®¡ç†å’Œè¨­å®šæŒ‡å—

æœ¬æ‰‹å†Šç‚ºç³»çµ±ç®¡ç†è€…æä¾›å®Œæ•´çš„ç³»çµ±ç®¡ç†ã€ä½¿ç”¨è€…ç®¡ç†ã€æ¬Šé™æ§åˆ¶å’Œç›£æ§æŒ‡å°ã€‚

## ç›®éŒ„

1. [ç®¡ç†è€…è·è²¬æ¦‚è¿°](#ç®¡ç†è€…è·è²¬æ¦‚è¿°)
2. [ç³»çµ±æ¶æ§‹ç®¡ç†](#ç³»çµ±æ¶æ§‹ç®¡ç†)
3. [ä½¿ç”¨è€…èˆ‡æ¬Šé™ç®¡ç†](#ä½¿ç”¨è€…èˆ‡æ¬Šé™ç®¡ç†)
4. [å…§å®¹ç™¼å¸ƒç®¡ç†](#å…§å®¹ç™¼å¸ƒç®¡ç†)
5. [å“è³ªç›£æ§èˆ‡åˆ†æ](#å“è³ªç›£æ§èˆ‡åˆ†æ)
6. [ç³»çµ±ç¶­è­·èˆ‡å‚™ä»½](#ç³»çµ±ç¶­è­·èˆ‡å‚™ä»½)
7. [å®‰å…¨æ€§ç®¡ç†](#å®‰å…¨æ€§ç®¡ç†)
8. [æ•…éšœæ’é™¤èˆ‡æ”¯æ´](#æ•…éšœæ’é™¤èˆ‡æ”¯æ´)

## ç®¡ç†è€…è·è²¬æ¦‚è¿°

### ä¸»è¦è·è²¬

1. **ç³»çµ±é‹ç¶­ç®¡ç†**
   - ç›£æ§ç³»çµ±é‹è¡Œç‹€æ…‹
   - ç®¡ç†ä¼ºæœå™¨è³‡æºå’Œæ•ˆèƒ½
   - åŸ·è¡Œç³»çµ±æ›´æ–°å’Œç¶­è­·
   - è™•ç†æŠ€è¡“æ•…éšœå’Œå•é¡Œ

2. **ä½¿ç”¨è€…ç®¡ç†**
   - ç®¡ç†ä½¿ç”¨è€…å¸³è™Ÿå’Œæ¬Šé™
   - å¯©æ ¸æ–°ä½¿ç”¨è€…ç”³è«‹
   - è™•ç†æ¬Šé™è®Šæ›´è«‹æ±‚
   - ç®¡ç†å¯©æ ¸è€…åˆ†é…

3. **å…§å®¹ç®¡ç†**
   - ç›£æ§å…§å®¹å“è³ªå’Œåˆè¦æ€§
   - ç®¡ç†ç™¼å¸ƒæµç¨‹å’Œæ™‚ç¨‹
   - è™•ç†å…§å®¹çˆ­è­°å’Œç”³è¨´
   - ç¶­è­·å…§å®¹æ¨™æº–å’ŒæŒ‡å¼•

4. **å®‰å…¨ç®¡ç†**
   - å¯¦æ–½å®‰å…¨æ”¿ç­–å’Œç¨‹åº
   - ç›£æ§å®‰å…¨å¨è„…å’Œæ¼æ´
   - ç®¡ç†å­˜å–æ§åˆ¶å’Œèªè­‰
   - åŸ·è¡Œå®‰å…¨ç¨½æ ¸å’Œè©•ä¼°

### ç®¡ç†å·¥å…·å­˜å–

**ä¸»è¦ç®¡ç†ä»‹é¢ï¼š**
- **GitHub çµ„ç¹”ç®¡ç†**ï¼šhttps://github.com/orgs/your-org/settings
- **Cloudflare Pages æ§åˆ¶å°**ï¼šhttps://dash.cloudflare.com/
- **ç³»çµ±ç›£æ§å„€è¡¨æ¿**ï¼šhttps://your-domain.com/admin/dashboard
- **ä½¿ç”¨è€…ç®¡ç†ä»‹é¢**ï¼šhttps://your-domain.com/admin/users

**å¿…è¦æ¬Šé™ï¼š**
- GitHub çµ„ç¹” Owner æ¬Šé™
- Cloudflare å¸³è™Ÿç®¡ç†æ¬Šé™
- ç³»çµ±ç®¡ç†è€…è§’è‰²
- è³‡æ–™åº«ç®¡ç†æ¬Šé™

## ç³»çµ±æ¶æ§‹ç®¡ç†

### ç³»çµ±çµ„ä»¶æ¦‚è¦½

```mermaid
graph TB
    subgraph "å‰ç«¯ç³»çµ±"
        A[Astro éœæ…‹ç¶²ç«™]
        B[Decap CMS ä»‹é¢]
        C[ç®¡ç†è€…å„€è¡¨æ¿]
    end
    
    subgraph "ç‰ˆæœ¬æ§åˆ¶"
        D[GitHub Repository]
        E[Pull Request å·¥ä½œæµç¨‹]
        F[GitHub Actions]
    end
    
    subgraph "éƒ¨ç½²å¹³å°"
        G[Cloudflare Pages]
        H[é è¦½ç’°å¢ƒ]
        I[ç”Ÿç”¢ç’°å¢ƒ]
    end
    
    subgraph "ç›£æ§ç³»çµ±"
        J[æ•ˆèƒ½ç›£æ§]
        K[éŒ¯èª¤è¿½è¹¤]
        L[ä½¿ç”¨è€…åˆ†æ]
    end
    
    A --> G
    B --> D
    D --> E
    E --> F
    F --> G
    G --> H
    G --> I
    J --> L
    K --> L
```

### GitHub çµ„ç¹”ç®¡ç†

#### å„²å­˜åº«è¨­å®š

1. **åˆ†æ”¯ä¿è­·è¦å‰‡**
   ```yaml
   # .github/branch-protection.yml
   protection_rules:
     main:
       required_status_checks:
         - content-quality-check
         - accessibility-check
         - medical-terminology-check
       required_reviews: 2
       dismiss_stale_reviews: true
       require_code_owner_reviews: true
       restrictions:
         users: []
         teams: ["admin-team"]
   ```

2. **CODEOWNERS è¨­å®š**
   ```
   # .github/CODEOWNERS
   
   # å…¨åŸŸç®¡ç†è€…
   * @admin-team
   
   # å°ˆç§‘ç‰¹å®šå¯©æ ¸è€…
   /src/content/education/*cardiology* @cardiology-reviewers @medical-editors
   /src/content/education/*pediatrics* @pediatrics-reviewers @medical-editors
   /src/content/education/*neurology* @neurology-reviewers @medical-editors
   
   # ç³»çµ±è¨­å®šæª”æ¡ˆ
   /.github/ @admin-team @tech-team
   /public/admin/ @admin-team @tech-team
   ```

3. **åœ˜éšŠç®¡ç†**
   - **admin-team**ï¼šç³»çµ±ç®¡ç†è€…
   - **tech-team**ï¼šæŠ€è¡“é–‹ç™¼åœ˜éšŠ
   - **medical-editors**ï¼šé†«å­¸ç·¨è¼¯åœ˜éšŠ
   - **cardiology-reviewers**ï¼šå¿ƒè‡Ÿç§‘å¯©æ ¸è€…
   - **pediatrics-reviewers**ï¼šå°å…’ç§‘å¯©æ ¸è€…
   - **neurology-reviewers**ï¼šç¥ç¶“ç§‘å¯©æ ¸è€…

#### GitHub Actions ç®¡ç†

1. **å·¥ä½œæµç¨‹ç›£æ§**
   ```bash
   # æŸ¥çœ‹å·¥ä½œæµç¨‹ç‹€æ…‹
   gh workflow list
   
   # æŸ¥çœ‹ç‰¹å®šå·¥ä½œæµç¨‹çš„åŸ·è¡Œæ­·å²
   gh run list --workflow="Content Quality Check"
   
   # æŸ¥çœ‹å¤±æ•—çš„å·¥ä½œæµç¨‹è©³æƒ…
   gh run view [RUN_ID] --log-failed
   ```

2. **Secrets ç®¡ç†**
   ```yaml
   # å¿…è¦çš„ Secrets è¨­å®š
   CLOUDFLARE_API_TOKEN: "your-cloudflare-api-token"
   GITHUB_TOKEN: "auto-generated"
   MEDICAL_TERMINOLOGY_API_KEY: "your-api-key"
   NOTIFICATION_WEBHOOK_URL: "your-webhook-url"
   ```

### Cloudflare Pages ç®¡ç†

#### éƒ¨ç½²è¨­å®š

1. **å»ºç½®è¨­å®š**
   ```yaml
   # cloudflare-pages.yml
   build:
     command: "npm run build"
     output_directory: "dist"
     environment_variables:
       NODE_VERSION: "18"
       NPM_VERSION: "9"
   
   preview:
     enabled: true
     branch_pattern: "*"
     
   production:
     branch: "main"
     custom_domain: "your-domain.com"
   ```

2. **ç’°å¢ƒè®Šæ•¸ç®¡ç†**
   - **SITE_URL**ï¼šç¶²ç«™ä¸»è¦ç¶²å€
   - **CMS_REPO**ï¼šGitHub å„²å­˜åº«è·¯å¾‘
   - **GITHUB_CLIENT_ID**ï¼šGitHub OAuth æ‡‰ç”¨ç¨‹å¼ ID
   - **ANALYTICS_ID**ï¼šåˆ†æå·¥å…· ID

#### è‡ªè¨‚ç¶²åŸŸè¨­å®š

1. **DNS è¨­å®š**
   ```
   Type: CNAME
   Name: your-domain.com
   Value: your-pages-project.pages.dev
   TTL: Auto
   ```

2. **SSL æ†‘è­‰**
   - å•Ÿç”¨ Cloudflare çš„ Universal SSL
   - è¨­å®š HTTPS é‡å°å‘
   - é…ç½® HSTS æ¨™é ­

### ç›£æ§èˆ‡åˆ†æ

#### æ•ˆèƒ½ç›£æ§

1. **Core Web Vitals ç›£æ§**
   ```javascript
   // src/utils/performance-monitor.js
   export class PerformanceMonitor {
     static trackCoreWebVitals() {
       // LCP (Largest Contentful Paint)
       new PerformanceObserver((list) => {
         const entries = list.getEntries();
         const lastEntry = entries[entries.length - 1];
         console.log('LCP:', lastEntry.startTime);
         this.sendMetric('lcp', lastEntry.startTime);
       }).observe({ entryTypes: ['largest-contentful-paint'] });
       
       // FID (First Input Delay)
       new PerformanceObserver((list) => {
         const entries = list.getEntries();
         entries.forEach((entry) => {
           console.log('FID:', entry.processingStart - entry.startTime);
           this.sendMetric('fid', entry.processingStart - entry.startTime);
         });
       }).observe({ entryTypes: ['first-input'] });
       
       // CLS (Cumulative Layout Shift)
       let clsValue = 0;
       new PerformanceObserver((list) => {
         const entries = list.getEntries();
         entries.forEach((entry) => {
           if (!entry.hadRecentInput) {
             clsValue += entry.value;
           }
         });
         console.log('CLS:', clsValue);
         this.sendMetric('cls', clsValue);
       }).observe({ entryTypes: ['layout-shift'] });
     }
   }
   ```

2. **éŒ¯èª¤è¿½è¹¤**
   ```javascript
   // src/utils/error-tracking.js
   export class ErrorTracker {
     static init() {
       window.addEventListener('error', (event) => {
         this.logError({
           type: 'javascript-error',
           message: event.message,
           filename: event.filename,
           lineno: event.lineno,
           colno: event.colno,
           stack: event.error?.stack
         });
       });
       
       window.addEventListener('unhandledrejection', (event) => {
         this.logError({
           type: 'promise-rejection',
           message: event.reason?.message || 'Unhandled Promise Rejection',
           stack: event.reason?.stack
         });
       });
     }
   }
   ```

## ä½¿ç”¨è€…èˆ‡æ¬Šé™ç®¡ç†

### ä½¿ç”¨è€…è§’è‰²å®šç¾©

```yaml
# è§’è‰²æ¬Šé™çŸ©é™£
roles:
  admin:
    permissions:
      - system_management
      - user_management
      - content_publish
      - all_content_access
      - analytics_access
      
  medical_editor:
    permissions:
      - content_review
      - content_edit
      - quality_check
      - analytics_view
      
  specialty_reviewer:
    permissions:
      - specialty_content_review
      - content_comment
      - preview_access
      
  content_writer:
    permissions:
      - content_create
      - content_edit_own
      - draft_management
      
  viewer:
    permissions:
      - published_content_view
```

### GitHub åœ˜éšŠç®¡ç†

#### å»ºç«‹æ–°åœ˜éšŠ

```bash
# ä½¿ç”¨ GitHub CLI å»ºç«‹åœ˜éšŠ
gh api orgs/your-org/teams \
  --method POST \
  --field name="cardiology-reviewers" \
  --field description="å¿ƒè‡Ÿç§‘å¯©æ ¸è€…åœ˜éšŠ" \
  --field privacy="closed"

# æ–°å¢æˆå“¡åˆ°åœ˜éšŠ
gh api orgs/your-org/teams/cardiology-reviewers/memberships/username \
  --method PUT \
  --field role="member"
```

#### æ¬Šé™ç®¡ç†è…³æœ¬

```javascript
// scripts/manage-permissions.js
import { Octokit } from '@octokit/rest';

class PermissionManager {
  constructor(token) {
    this.octokit = new Octokit({ auth: token });
  }
  
  async addUserToTeam(org, teamSlug, username, role = 'member') {
    try {
      await this.octokit.teams.addOrUpdateMembershipForUserInOrg({
        org,
        team_slug: teamSlug,
        username,
        role
      });
      console.log(`âœ… Added ${username} to ${teamSlug} as ${role}`);
    } catch (error) {
      console.error(`âŒ Failed to add ${username} to ${teamSlug}:`, error.message);
    }
  }
  
  async removeUserFromTeam(org, teamSlug, username) {
    try {
      await this.octokit.teams.removeMembershipForUserInOrg({
        org,
        team_slug: teamSlug,
        username
      });
      console.log(`âœ… Removed ${username} from ${teamSlug}`);
    } catch (error) {
      console.error(`âŒ Failed to remove ${username} from ${teamSlug}:`, error.message);
    }
  }
  
  async listTeamMembers(org, teamSlug) {
    try {
      const { data } = await this.octokit.teams.listMembersInOrg({
        org,
        team_slug: teamSlug
      });
      return data.map(member => ({
        username: member.login,
        role: member.role || 'member'
      }));
    } catch (error) {
      console.error(`âŒ Failed to list members of ${teamSlug}:`, error.message);
      return [];
    }
  }
}

// ä½¿ç”¨ç¯„ä¾‹
const pm = new PermissionManager(process.env.GITHUB_TOKEN);

// æ–°å¢ä½¿ç”¨è€…åˆ°å¿ƒè‡Ÿç§‘å¯©æ ¸åœ˜éšŠ
await pm.addUserToTeam('your-org', 'cardiology-reviewers', 'dr-chen');

// åˆ—å‡ºæ‰€æœ‰åœ˜éšŠæˆå“¡
const members = await pm.listTeamMembers('your-org', 'cardiology-reviewers');
console.log('Team members:', members);
```

### Decap CMS ä½¿ç”¨è€…ç®¡ç†

#### ä½¿ç”¨è€…èªè­‰è¨­å®š

```yaml
# public/admin/config.yml
backend:
  name: github
  repo: your-org/health-education-platform
  branch: main
  auth_endpoint: https://your-domain.com/api/auth
  
# ä½¿ç”¨è€…è§’è‰²è¨­å®š
collections:
  - name: "education"
    label: "è¡›æ•™æ–‡ç« "
    folder: "src/content/education"
    create: true
    slug: "{{year}}-{{month}}-{{day}}-{{slug}}"
    editor:
      preview: true
    fields:
      # ... å…¶ä»–æ¬„ä½
    # è§’è‰²æ¬Šé™æ§åˆ¶
    access:
      create: ["admin", "medical_editor", "content_writer"]
      update: ["admin", "medical_editor", "content_writer"]
      delete: ["admin"]
      publish: ["admin", "medical_editor"]
```

#### ä½¿ç”¨è€…å¯©æ ¸æµç¨‹

1. **æ–°ä½¿ç”¨è€…ç”³è«‹**
   ```javascript
   // scripts/user-approval.js
   class UserApprovalSystem {
     async processNewUserRequest(userData) {
       // é©—è­‰ä½¿ç”¨è€…è³‡æ ¼
       const isQualified = await this.verifyUserQualifications(userData);
       
       if (isQualified) {
         // å»ºç«‹ GitHub é‚€è«‹
         await this.createGitHubInvitation(userData.githubUsername);
         
         // åˆ†é…é©ç•¶çš„åœ˜éšŠ
         await this.assignUserToTeams(userData);
         
         // ç™¼é€æ­¡è¿éƒµä»¶
         await this.sendWelcomeEmail(userData);
         
         console.log(`âœ… Approved user: ${userData.email}`);
       } else {
         // ç™¼é€æ‹’çµ•é€šçŸ¥
         await this.sendRejectionEmail(userData);
         console.log(`âŒ Rejected user: ${userData.email}`);
       }
     }
   }
   ```

## å…§å®¹ç™¼å¸ƒç®¡ç†

### ç™¼å¸ƒæµç¨‹æ§åˆ¶

#### è‡ªå‹•åŒ–ç™¼å¸ƒè¨­å®š

```yaml
# .github/workflows/auto-publish.yml
name: Auto Publish Approved Content

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  auto-publish:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Check if content is ready for publish
        id: check-status
        run: |
          # æª¢æŸ¥ PR æ¨™ç±¤æ˜¯å¦åŒ…å« "ready-to-publish"
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'ready-to-publish') }}" == "true" ]]; then
            echo "publish=true" >> $GITHUB_OUTPUT
          else
            echo "publish=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Trigger deployment
        if: steps.check-status.outputs.publish == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            // è§¸ç™¼ Cloudflare Pages éƒ¨ç½²
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'deploy-production'
            });
      
      - name: Notify stakeholders
        if: steps.check-status.outputs.publish == 'true'
        run: |
          # ç™¼é€ç™¼å¸ƒé€šçŸ¥
          curl -X POST "${{ secrets.NOTIFICATION_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "ğŸš€ New content published: ${{ github.event.pull_request.title }}",
              "url": "${{ github.event.pull_request.html_url }}"
            }'
```

#### æ‰‹å‹•ç™¼å¸ƒæ§åˆ¶

```javascript
// src/utils/publish-manager.js
export class PublishManager {
  constructor(githubToken) {
    this.octokit = new Octokit({ auth: githubToken });
  }
  
  async publishContent(prNumber, adminUser) {
    try {
      // æª¢æŸ¥ç®¡ç†è€…æ¬Šé™
      const hasPermission = await this.checkAdminPermission(adminUser);
      if (!hasPermission) {
        throw new Error('Insufficient permissions');
      }
      
      // ç²å– PR è³‡è¨Š
      const pr = await this.octokit.pulls.get({
        owner: 'your-org',
        repo: 'health-education-platform',
        pull_number: prNumber
      });
      
      // æª¢æŸ¥ PR ç‹€æ…‹
      if (pr.data.state !== 'open') {
        throw new Error('PR is not open');
      }
      
      // æª¢æŸ¥æ‰€æœ‰æª¢æŸ¥æ˜¯å¦é€šé
      const checks = await this.octokit.checks.listForRef({
        owner: 'your-org',
        repo: 'health-education-platform',
        ref: pr.data.head.sha
      });
      
      const allChecksPassed = checks.data.check_runs.every(
        check => check.conclusion === 'success'
      );
      
      if (!allChecksPassed) {
        throw new Error('Not all checks have passed');
      }
      
      // æ–°å¢ ready-to-publish æ¨™ç±¤
      await this.octokit.issues.addLabels({
        owner: 'your-org',
        repo: 'health-education-platform',
        issue_number: prNumber,
        labels: ['ready-to-publish']
      });
      
      // åˆä½µ PR
      await this.octokit.pulls.merge({
        owner: 'your-org',
        repo: 'health-education-platform',
        pull_number: prNumber,
        commit_title: `Publish: ${pr.data.title}`,
        merge_method: 'squash'
      });
      
      console.log(`âœ… Successfully published PR #${prNumber}`);
      return { success: true, message: 'Content published successfully' };
      
    } catch (error) {
      console.error(`âŒ Failed to publish PR #${prNumber}:`, error.message);
      return { success: false, error: error.message };
    }
  }
}
```

### å…§å®¹å“è³ªç›£æ§

#### å“è³ªæŒ‡æ¨™è¿½è¹¤

```javascript
// src/utils/quality-metrics.js
export class QualityMetrics {
  static async generateQualityReport() {
    const metrics = {
      totalArticles: 0,
      publishedArticles: 0,
      averageReviewTime: 0,
      qualityScores: {},
      commonIssues: []
    };
    
    // åˆ†ææ‰€æœ‰æ–‡ç« 
    const articles = await this.getAllArticles();
    metrics.totalArticles = articles.length;
    
    // è¨ˆç®—ç™¼å¸ƒç‡
    const publishedArticles = articles.filter(a => a.status === 'published');
    metrics.publishedArticles = publishedArticles.length;
    
    // è¨ˆç®—å¹³å‡å¯©æ ¸æ™‚é–“
    const reviewTimes = articles
      .filter(a => a.reviewCompletedAt && a.reviewStartedAt)
      .map(a => a.reviewCompletedAt - a.reviewStartedAt);
    
    if (reviewTimes.length > 0) {
      metrics.averageReviewTime = reviewTimes.reduce((a, b) => a + b, 0) / reviewTimes.length;
    }
    
    // åˆ†æå“è³ªåˆ†æ•¸
    metrics.qualityScores = await this.calculateQualityScores(articles);
    
    // è­˜åˆ¥å¸¸è¦‹å•é¡Œ
    metrics.commonIssues = await this.identifyCommonIssues(articles);
    
    return metrics;
  }
  
  static async calculateQualityScores(articles) {
    const scores = {
      medical_accuracy: 0,
      content_structure: 0,
      language_quality: 0,
      accessibility: 0
    };
    
    for (const article of articles) {
      const qualityChecks = await this.getQualityChecks(article.id);
      
      Object.keys(scores).forEach(metric => {
        if (qualityChecks[metric]) {
          scores[metric] += qualityChecks[metric].score || 0;
        }
      });
    }
    
    // è¨ˆç®—å¹³å‡åˆ†æ•¸
    Object.keys(scores).forEach(metric => {
      scores[metric] = scores[metric] / articles.length;
    });
    
    return scores;
  }
}
```

#### è‡ªå‹•å“è³ªæª¢æŸ¥

```javascript
// scripts/quality-checker.js
import { MedicalTerminologyChecker } from './medical-terminology-checker.js';
import { AccessibilityValidator } from './accessibility-validator.js';
import { ReadabilityAnalyzer } from './readability-analyzer.js';

export class AutoQualityChecker {
  constructor() {
    this.checkers = [
      new MedicalTerminologyChecker(),
      new AccessibilityValidator(),
      new ReadabilityAnalyzer()
    ];
  }
  
  async runAllChecks(articleContent, metadata) {
    const results = {
      overall_score: 0,
      checks: {},
      issues: [],
      recommendations: []
    };
    
    for (const checker of this.checkers) {
      try {
        const checkResult = await checker.check(articleContent, metadata);
        results.checks[checker.name] = checkResult;
        
        if (checkResult.issues) {
          results.issues.push(...checkResult.issues);
        }
        
        if (checkResult.recommendations) {
          results.recommendations.push(...checkResult.recommendations);
        }
        
        results.overall_score += checkResult.score || 0;
        
      } catch (error) {
        console.error(`Quality check failed for ${checker.name}:`, error);
        results.checks[checker.name] = {
          status: 'error',
          message: error.message
        };
      }
    }
    
    // è¨ˆç®—ç¸½é«”åˆ†æ•¸
    results.overall_score = results.overall_score / this.checkers.length;
    
    return results;
  }
}
```

## å“è³ªç›£æ§èˆ‡åˆ†æ

### åˆ†æå„€è¡¨æ¿

#### å…§å®¹çµ±è¨ˆåˆ†æ

```javascript
// src/components/AdminDashboard.astro
---
import { getCollection } from 'astro:content';
import { QualityMetrics } from '../utils/quality-metrics.js';

// ç²å–å…§å®¹çµ±è¨ˆ
const allArticles = await getCollection('education');
const publishedArticles = allArticles.filter(article => article.data.status === 'published');
const draftArticles = allArticles.filter(article => article.data.status === 'draft');
const reviewingArticles = allArticles.filter(article => article.data.status === 'in-review');

// å°ˆç§‘åˆ†å¸ƒçµ±è¨ˆ
const specialtyStats = {};
allArticles.forEach(article => {
  const specialty = article.data.specialty;
  if (!specialtyStats[specialty]) {
    specialtyStats[specialty] = { total: 0, published: 0, draft: 0, reviewing: 0 };
  }
  specialtyStats[specialty].total++;
  specialtyStats[specialty][article.data.status]++;
});

// å“è³ªæŒ‡æ¨™
const qualityMetrics = await QualityMetrics.generateQualityReport();
---

<div class="admin-dashboard">
  <div class="stats-grid">
    <div class="stat-card">
      <h3>ç¸½æ–‡ç« æ•¸</h3>
      <div class="stat-number">{allArticles.length}</div>
    </div>
    
    <div class="stat-card">
      <h3>å·²ç™¼å¸ƒ</h3>
      <div class="stat-number">{publishedArticles.length}</div>
      <div class="stat-percentage">
        {Math.round((publishedArticles.length / allArticles.length) * 100)}%
      </div>
    </div>
    
    <div class="stat-card">
      <h3>å¯©æ ¸ä¸­</h3>
      <div class="stat-number">{reviewingArticles.length}</div>
    </div>
    
    <div class="stat-card">
      <h3>è‰ç¨¿</h3>
      <div class="stat-number">{draftArticles.length}</div>
    </div>
  </div>
  
  <div class="charts-grid">
    <div class="chart-container">
      <h3>å°ˆç§‘åˆ†å¸ƒ</h3>
      <canvas id="specialty-chart"></canvas>
    </div>
    
    <div class="chart-container">
      <h3>å“è³ªåˆ†æ•¸è¶¨å‹¢</h3>
      <canvas id="quality-trend-chart"></canvas>
    </div>
  </div>
  
  <div class="quality-metrics">
    <h3>å“è³ªæŒ‡æ¨™</h3>
    <div class="metrics-grid">
      <div class="metric-item">
        <span class="metric-label">é†«å­¸æº–ç¢ºæ€§</span>
        <div class="metric-bar">
          <div class="metric-fill" style={`width: ${qualityMetrics.qualityScores.medical_accuracy}%`}></div>
        </div>
        <span class="metric-value">{qualityMetrics.qualityScores.medical_accuracy.toFixed(1)}</span>
      </div>
      
      <div class="metric-item">
        <span class="metric-label">å…§å®¹çµæ§‹</span>
        <div class="metric-bar">
          <div class="metric-fill" style={`width: ${qualityMetrics.qualityScores.content_structure}%`}></div>
        </div>
        <span class="metric-value">{qualityMetrics.qualityScores.content_structure.toFixed(1)}</span>
      </div>
      
      <div class="metric-item">
        <span class="metric-label">èªè¨€å“è³ª</span>
        <div class="metric-bar">
          <div class="metric-fill" style={`width: ${qualityMetrics.qualityScores.language_quality}%`}></div>
        </div>
        <span class="metric-value">{qualityMetrics.qualityScores.language_quality.toFixed(1)}</span>
      </div>
      
      <div class="metric-item">
        <span class="metric-label">ç„¡éšœç¤™æ€§</span>
        <div class="metric-bar">
          <div class="metric-fill" style={`width: ${qualityMetrics.qualityScores.accessibility}%`}></div>
        </div>
        <span class="metric-value">{qualityMetrics.qualityScores.accessibility.toFixed(1)}</span>
      </div>
    </div>
  </div>
</div>

<script>
  // åˆå§‹åŒ–åœ–è¡¨
  import Chart from 'chart.js/auto';
  
  // å°ˆç§‘åˆ†å¸ƒåœ“é¤…åœ–
  const specialtyCtx = document.getElementById('specialty-chart').getContext('2d');
  new Chart(specialtyCtx, {
    type: 'doughnut',
    data: {
      labels: Object.keys(specialtyStats),
      datasets: [{
        data: Object.values(specialtyStats).map(stat => stat.total),
        backgroundColor: [
          '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'
        ]
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: {
          position: 'bottom'
        }
      }
    }
  });
</script>
```

### ä½¿ç”¨è€…è¡Œç‚ºåˆ†æ

```javascript
// src/utils/analytics.js
export class AnalyticsManager {
  static async trackUserBehavior(event, data) {
    // ç™¼é€åˆ†æè³‡æ–™åˆ°åˆ†ææœå‹™
    try {
      await fetch('/api/analytics', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          event,
          data,
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          url: window.location.href
        })
      });
    } catch (error) {
      console.error('Analytics tracking failed:', error);
    }
  }
  
  static async generateUserReport() {
    const response = await fetch('/api/analytics/report');
    const data = await response.json();
    
    return {
      totalUsers: data.totalUsers,
      activeUsers: data.activeUsers,
      topPages: data.topPages,
      userJourney: data.userJourney,
      deviceStats: data.deviceStats,
      locationStats: data.locationStats
    };
  }
}

// ä½¿ç”¨ç¯„ä¾‹
document.addEventListener('DOMContentLoaded', () => {
  // è¿½è¹¤é é¢ç€è¦½
  AnalyticsManager.trackUserBehavior('page_view', {
    page: window.location.pathname,
    title: document.title
  });
  
  // è¿½è¹¤æ–‡ç« é–±è®€
  const articleContent = document.querySelector('.article-content');
  if (articleContent) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          AnalyticsManager.trackUserBehavior('article_read', {
            article: document.querySelector('h1').textContent,
            scrollDepth: Math.round((window.scrollY / document.body.scrollHeight) * 100)
          });
        }
      });
    });
    
    observer.observe(articleContent);
  }
});
```

## ç³»çµ±ç¶­è­·èˆ‡å‚™ä»½

### å®šæœŸç¶­è­·ä»»å‹™

#### è‡ªå‹•åŒ–ç¶­è­·è…³æœ¬

```bash
#!/bin/bash
# scripts/maintenance.sh

echo "ğŸ”§ Starting system maintenance..."

# 1. æ¸…ç†èˆŠçš„é è¦½éƒ¨ç½²
echo "ğŸ“¦ Cleaning up old preview deployments..."
gh api repos/your-org/health-education-platform/deployments \
  --jq '.[] | select(.environment == "preview" and (.created_at | fromdateiso8601) < (now - 604800)) | .id' \
  | xargs -I {} gh api repos/your-org/health-education-platform/deployments/{}/statuses \
    --method POST \
    --field state="inactive"

# 2. æ›´æ–°ä¾è³´å¥—ä»¶
echo "ğŸ“¦ Updating dependencies..."
npm audit fix
npm update

# 3. åŸ·è¡Œå®‰å…¨æƒæ
echo "ğŸ”’ Running security scan..."
npm audit --audit-level moderate

# 4. æ¸…ç† GitHub Actions å¿«å–
echo "ğŸ—‘ï¸ Cleaning up GitHub Actions cache..."
gh cache list --limit 100 | grep -E "refs/pull/[0-9]+/merge" | awk '{print $1}' | xargs -I {} gh cache delete {}

# 5. æª¢æŸ¥ç³»çµ±å¥åº·ç‹€æ…‹
echo "ğŸ¥ Checking system health..."
curl -f https://your-domain.com/health || echo "âŒ Health check failed"

# 6. ç”Ÿæˆç¶­è­·å ±å‘Š
echo "ğŸ“Š Generating maintenance report..."
node scripts/generate-maintenance-report.js

echo "âœ… Maintenance completed successfully"
```

#### è³‡æ–™å‚™ä»½ç­–ç•¥

```javascript
// scripts/backup-manager.js
import { Octokit } from '@octokit/rest';
import { createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';

export class BackupManager {
  constructor(githubToken) {
    this.octokit = new Octokit({ auth: githubToken });
  }
  
  async createFullBackup() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupDir = `backups/full-backup-${timestamp}`;
    
    try {
      // 1. å‚™ä»½ GitHub å„²å­˜åº«
      await this.backupRepository(backupDir);
      
      // 2. å‚™ä»½ä½¿ç”¨è€…è³‡æ–™
      await this.backupUserData(backupDir);
      
      // 3. å‚™ä»½ç³»çµ±è¨­å®š
      await this.backupSystemConfig(backupDir);
      
      // 4. å‚™ä»½åˆ†æè³‡æ–™
      await this.backupAnalyticsData(backupDir);
      
      // 5. å»ºç«‹å‚™ä»½ç´¢å¼•
      await this.createBackupIndex(backupDir);
      
      console.log(`âœ… Full backup completed: ${backupDir}`);
      return backupDir;
      
    } catch (error) {
      console.error('âŒ Backup failed:', error);
      throw error;
    }
  }
  
  async backupRepository(backupDir) {
    // ä¸‹è¼‰å„²å­˜åº«çš„å®Œæ•´å¿«ç…§
    const { data } = await this.octokit.repos.downloadZipballArchive({
      owner: 'your-org',
      repo: 'health-education-platform',
      ref: 'main'
    });
    
    const fs = require('fs');
    const path = require('path');
    
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }
    
    const zipPath = path.join(backupDir, 'repository.zip');
    const writeStream = createWriteStream(zipPath);
    
    await pipeline(data, writeStream);
    console.log(`ğŸ“¦ Repository backed up to ${zipPath}`);
  }
  
  async backupUserData(backupDir) {
    // å‚™ä»½åœ˜éšŠå’Œæˆå“¡è³‡è¨Š
    const teams = await this.octokit.teams.list({
      org: 'your-org'
    });
    
    const userData = {
      teams: teams.data,
      members: {}
    };
    
    // ç²å–æ¯å€‹åœ˜éšŠçš„æˆå“¡
    for (const team of teams.data) {
      const members = await this.octokit.teams.listMembersInOrg({
        org: 'your-org',
        team_slug: team.slug
      });
      userData.members[team.slug] = members.data;
    }
    
    const fs = require('fs');
    const path = require('path');
    
    fs.writeFileSync(
      path.join(backupDir, 'user-data.json'),
      JSON.stringify(userData, null, 2)
    );
    
    console.log('ğŸ‘¥ User data backed up');
  }
  
  async restoreFromBackup(backupDir) {
    try {
      console.log(`ğŸ”„ Starting restore from ${backupDir}`);
      
      // 1. é©—è­‰å‚™ä»½å®Œæ•´æ€§
      await this.validateBackup(backupDir);
      
      // 2. é‚„åŸä½¿ç”¨è€…è³‡æ–™
      await this.restoreUserData(backupDir);
      
      // 3. é‚„åŸç³»çµ±è¨­å®š
      await this.restoreSystemConfig(backupDir);
      
      console.log('âœ… Restore completed successfully');
      
    } catch (error) {
      console.error('âŒ Restore failed:', error);
      throw error;
    }
  }
}

// å®šæœŸå‚™ä»½æ’ç¨‹
import cron from 'node-cron';

const backupManager = new BackupManager(process.env.GITHUB_TOKEN);

// æ¯æ—¥å‚™ä»½ï¼ˆå‡Œæ™¨ 2 é»ï¼‰
cron.schedule('0 2 * * *', async () => {
  console.log('ğŸ• Starting scheduled backup...');
  try {
    await backupManager.createFullBackup();
  } catch (error) {
    console.error('Scheduled backup failed:', error);
    // ç™¼é€è­¦å ±é€šçŸ¥
  }
});

// æ¯é€±å®Œæ•´å‚™ä»½ï¼ˆé€±æ—¥å‡Œæ™¨ 1 é»ï¼‰
cron.schedule('0 1 * * 0', async () => {
  console.log('ğŸ• Starting weekly full backup...');
  try {
    const backupDir = await backupManager.createFullBackup();
    // ä¸Šå‚³åˆ°é›²ç«¯å„²å­˜
    await uploadToCloudStorage(backupDir);
  } catch (error) {
    console.error('Weekly backup failed:', error);
  }
});
```

### ç³»çµ±æ›´æ–°ç®¡ç†

```yaml
# .github/workflows/system-update.yml
name: System Update

on:
  schedule:
    # æ¯é€±æª¢æŸ¥æ›´æ–°
    - cron: '0 6 * * 1'
  workflow_dispatch:

jobs:
  check-updates:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Check for dependency updates
        run: |
          npm outdated --json > outdated.json || true
          
      - name: Create update PR
        if: ${{ hashFiles('outdated.json') != '' }}
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const outdated = JSON.parse(fs.readFileSync('outdated.json', 'utf8'));
            
            if (Object.keys(outdated).length > 0) {
              const updateList = Object.entries(outdated)
                .map(([pkg, info]) => `- ${pkg}: ${info.current} â†’ ${info.latest}`)
                .join('\n');
              
              await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'ğŸ”„ Automated dependency updates',
                head: 'automated-updates',
                base: 'main',
                body: `## ğŸ“¦ Dependency Updates\n\n${updateList}\n\nâš ï¸ Please review and test before merging.`
              });
            }
```

## å®‰å…¨æ€§ç®¡ç†

### å®‰å…¨æ”¿ç­–å¯¦æ–½

#### å­˜å–æ§åˆ¶

```yaml
# .github/security-policy.yml
security:
  access_control:
    # æœ€å°æ¬Šé™åŸå‰‡
    minimum_permissions: true
    
    # é›™å› å­èªè­‰è¦æ±‚
    require_2fa: true
    
    # IP ç™½åå–®ï¼ˆé¸ç”¨ï¼‰
    ip_whitelist:
      - "192.168.1.0/24"  # è¾¦å…¬å®¤ç¶²è·¯
      - "10.0.0.0/8"      # VPN ç¶²è·¯
    
    # æœƒè©±ç®¡ç†
    session:
      timeout: 3600  # 1 å°æ™‚
      max_concurrent: 3
      
  # å…§å®¹å®‰å…¨æ”¿ç­–
  content_security:
    # å…è¨±çš„æª”æ¡ˆé¡å‹
    allowed_file_types:
      - "image/jpeg"
      - "image/png"
      - "image/webp"
      - "application/pdf"
    
    # æª”æ¡ˆå¤§å°é™åˆ¶
    max_file_size: 10485760  # 10MB
    
    # å…§å®¹æƒæ
    virus_scan: true
    malware_scan: true
```

#### å®‰å…¨ç›£æ§

```javascript
// src/utils/security-monitor.js
export class SecurityMonitor {
  static async logSecurityEvent(event, details) {
    const securityLog = {
      timestamp: new Date().toISOString(),
      event,
      details,
      userAgent: details.userAgent || 'unknown',
      ip: details.ip || 'unknown',
      severity: this.calculateSeverity(event)
    };
    
    // è¨˜éŒ„åˆ°å®‰å…¨æ—¥èªŒ
    await this.writeSecurityLog(securityLog);
    
    // é«˜é¢¨éšªäº‹ä»¶ç«‹å³é€šçŸ¥
    if (securityLog.severity === 'high') {
      await this.sendSecurityAlert(securityLog);
    }
  }
  
  static calculateSeverity(event) {
    const highRiskEvents = [
      'unauthorized_access_attempt',
      'privilege_escalation',
      'malicious_file_upload',
      'sql_injection_attempt'
    ];
    
    const mediumRiskEvents = [
      'failed_login_attempt',
      'suspicious_activity',
      'rate_limit_exceeded'
    ];
    
    if (highRiskEvents.includes(event)) return 'high';
    if (mediumRiskEvents.includes(event)) return 'medium';
    return 'low';
  }
  
  static async detectAnomalousActivity(userId, activity) {
    // æª¢æŸ¥ç•°å¸¸æ´»å‹•æ¨¡å¼
    const recentActivity = await this.getUserRecentActivity(userId);
    
    const anomalies = [];
    
    // æª¢æŸ¥ç•°å¸¸ç™»å…¥æ™‚é–“
    if (this.isUnusualLoginTime(activity.timestamp, recentActivity)) {
      anomalies.push('unusual_login_time');
    }
    
    // æª¢æŸ¥ç•°å¸¸ IP ä½å€
    if (this.isUnusualIP(activity.ip, recentActivity)) {
      anomalies.push('unusual_ip_address');
    }
    
    // æª¢æŸ¥ç•°å¸¸æ´»å‹•é »ç‡
    if (this.isUnusualFrequency(activity, recentActivity)) {
      anomalies.push('unusual_activity_frequency');
    }
    
    if (anomalies.length > 0) {
      await this.logSecurityEvent('anomalous_activity', {
        userId,
        anomalies,
        activity
      });
    }
    
    return anomalies;
  }
}
```

### æ¼æ´ç®¡ç†

```javascript
// scripts/vulnerability-scanner.js
import { execSync } from 'child_process';

export class VulnerabilityScanner {
  static async runSecurityAudit() {
    const results = {
      npm_audit: null,
      dependency_check: null,
      code_scan: null,
      infrastructure_scan: null
    };
    
    try {
      // 1. NPM å®‰å…¨ç¨½æ ¸
      console.log('ğŸ” Running NPM security audit...');
      const npmAudit = execSync('npm audit --json', { encoding: 'utf8' });
      results.npm_audit = JSON.parse(npmAudit);
      
      // 2. ä¾è³´å¥—ä»¶æª¢æŸ¥
      console.log('ğŸ“¦ Checking dependencies...');
      results.dependency_check = await this.checkDependencies();
      
      // 3. ç¨‹å¼ç¢¼æƒæ
      console.log('ğŸ’» Scanning code...');
      results.code_scan = await this.scanCode();
      
      // 4. åŸºç¤è¨­æ–½æƒæ
      console.log('ğŸ—ï¸ Scanning infrastructure...');
      results.infrastructure_scan = await this.scanInfrastructure();
      
      // ç”Ÿæˆå ±å‘Š
      await this.generateSecurityReport(results);
      
      return results;
      
    } catch (error) {
      console.error('âŒ Security audit failed:', error);
      throw error;
    }
  }
  
  static async checkDependencies() {
    // æª¢æŸ¥å·²çŸ¥æ¼æ´è³‡æ–™åº«
    const vulnerablePackages = [];
    
    try {
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };
      
      for (const [pkg, version] of Object.entries(dependencies)) {
        const vulns = await this.checkPackageVulnerabilities(pkg, version);
        if (vulns.length > 0) {
          vulnerablePackages.push({ package: pkg, version, vulnerabilities: vulns });
        }
      }
      
    } catch (error) {
      console.error('Dependency check failed:', error);
    }
    
    return vulnerablePackages;
  }
  
  static async generateSecurityReport(results) {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        total_vulnerabilities: 0,
        high_severity: 0,
        medium_severity: 0,
        low_severity: 0
      },
      details: results,
      recommendations: []
    };
    
    // åˆ†æçµæœä¸¦ç”Ÿæˆå»ºè­°
    if (results.npm_audit && results.npm_audit.vulnerabilities) {
      Object.values(results.npm_audit.vulnerabilities).forEach(vuln => {
        report.summary.total_vulnerabilities++;
        report.summary[`${vuln.severity}_severity`]++;
        
        if (vuln.severity === 'high' || vuln.severity === 'critical') {
          report.recommendations.push(`ç«‹å³ä¿®å¾© ${vuln.module_name} çš„ ${vuln.severity} ç´šæ¼æ´`);
        }
      });
    }
    
    // å„²å­˜å ±å‘Š
    const fs = require('fs');
    fs.writeFileSync(
      `security-reports/security-report-${Date.now()}.json`,
      JSON.stringify(report, null, 2)
    );
    
    // å¦‚æœæœ‰é«˜é¢¨éšªæ¼æ´ï¼Œç™¼é€è­¦å ±
    if (report.summary.high_severity > 0) {
      await this.sendSecurityAlert(report);
    }
    
    console.log(`ğŸ“Š Security report generated: ${report.summary.total_vulnerabilities} vulnerabilities found`);
  }
}

// å®šæœŸå®‰å…¨æƒæ
import cron from 'node-cron';

// æ¯æ—¥å®‰å…¨æƒæï¼ˆå‡Œæ™¨ 3 é»ï¼‰
cron.schedule('0 3 * * *', async () => {
  console.log('ğŸ”’ Starting daily security scan...');
  try {
    await VulnerabilityScanner.runSecurityAudit();
  } catch (error) {
    console.error('Daily security scan failed:', error);
  }
});
```

## æ•…éšœæ’é™¤èˆ‡æ”¯æ´

### å¸¸è¦‹å•é¡Œè¨ºæ–·

#### ç³»çµ±å¥åº·æª¢æŸ¥

```javascript
// src/utils/health-checker.js
export class HealthChecker {
  static async performHealthCheck() {
    const checks = {
      github_api: await this.checkGitHubAPI(),
      cloudflare_pages: await this.checkCloudflarePages(),
      cms_backend: await this.checkCMSBackend(),
      external_services: await this.checkExternalServices(),
      database_connection: await this.checkDatabaseConnection()
    };
    
    const overallHealth = Object.values(checks).every(check => check.status === 'healthy');
    
    return {
      timestamp: new Date().toISOString(),
      overall_status: overallHealth ? 'healthy' : 'unhealthy',
      checks
    };
  }
  
  static async checkGitHubAPI() {
    try {
      const response = await fetch('https://api.github.com/rate_limit', {
        headers: {
          'Authorization': `token ${process.env.GITHUB_TOKEN}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        return {
          status: 'healthy',
          details: {
            rate_limit_remaining: data.rate.remaining,
            rate_limit_reset: new Date(data.rate.reset * 1000).toISOString()
          }
        };
      } else {
        return {
          status: 'unhealthy',
          error: `HTTP ${response.status}: ${response.statusText}`
        };
      }
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  }
  
  static async checkCloudflarePages() {
    try {
      const response = await fetch('https://your-domain.com/health');
      
      if (response.ok) {
        const responseTime = response.headers.get('x-response-time') || 'unknown';
        return {
          status: 'healthy',
          details: {
            response_time: responseTime,
            status_code: response.status
          }
        };
      } else {
        return {
          status: 'unhealthy',
          error: `HTTP ${response.status}: ${response.statusText}`
        };
      }
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  }
}

// å¥åº·æª¢æŸ¥ç«¯é»
// src/pages/api/health.ts
export async function GET() {
  const healthStatus = await HealthChecker.performHealthCheck();
  
  return new Response(JSON.stringify(healthStatus), {
    status: healthStatus.overall_status === 'healthy' ? 200 : 503,
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 'no-cache'
    }
  });
}
```

#### éŒ¯èª¤æ—¥èªŒåˆ†æ

```javascript
// src/utils/log-analyzer.js
export class LogAnalyzer {
  static async analyzeErrorLogs(timeRange = '24h') {
    const logs = await this.getErrorLogs(timeRange);
    
    const analysis = {
      total_errors: logs.length,
      error_types: {},
      error_trends: {},
      top_errors: [],
      affected_users: new Set(),
      recommendations: []
    };
    
    // åˆ†æéŒ¯èª¤é¡å‹
    logs.forEach(log => {
      const errorType = this.categorizeError(log);
      analysis.error_types[errorType] = (analysis.error_types[errorType] || 0) + 1;
      
      if (log.userId) {
        analysis.affected_users.add(log.userId);
      }
    });
    
    // æ‰¾å‡ºæœ€å¸¸è¦‹çš„éŒ¯èª¤
    analysis.top_errors = Object.entries(analysis.error_types)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .map(([type, count]) => ({ type, count }));
    
    // ç”Ÿæˆå»ºè­°
    analysis.recommendations = this.generateRecommendations(analysis);
    
    return analysis;
  }
  
  static categorizeError(log) {
    const message = log.message.toLowerCase();
    
    if (message.includes('network') || message.includes('fetch')) {
      return 'network_error';
    } else if (message.includes('permission') || message.includes('unauthorized')) {
      return 'permission_error';
    } else if (message.includes('validation') || message.includes('invalid')) {
      return 'validation_error';
    } else if (message.includes('timeout')) {
      return 'timeout_error';
    } else {
      return 'unknown_error';
    }
  }
  
  static generateRecommendations(analysis) {
    const recommendations = [];
    
    // åŸºæ–¼éŒ¯èª¤é¡å‹ç”Ÿæˆå»ºè­°
    Object.entries(analysis.error_types).forEach(([type, count]) => {
      if (count > 10) {  // å¦‚æœæŸé¡éŒ¯èª¤è¶…é 10 æ¬¡
        switch (type) {
          case 'network_error':
            recommendations.push('æª¢æŸ¥ç¶²è·¯é€£ç·šç©©å®šæ€§å’Œ API ç«¯é»ç‹€æ…‹');
            break;
          case 'permission_error':
            recommendations.push('æª¢æŸ¥ä½¿ç”¨è€…æ¬Šé™è¨­å®šå’Œèªè­‰æ©Ÿåˆ¶');
            break;
          case 'validation_error':
            recommendations.push('æª¢æŸ¥è¼¸å…¥é©—è­‰é‚è¼¯å’ŒéŒ¯èª¤è™•ç†');
            break;
          case 'timeout_error':
            recommendations.push('æª¢æŸ¥ä¼ºæœå™¨æ•ˆèƒ½å’Œè«‹æ±‚è¶…æ™‚è¨­å®š');
            break;
        }
      }
    });
    
    return recommendations;
  }
}
```

### æ”¯æ´å·¥å–®ç³»çµ±

```javascript
// src/utils/support-ticket.js
export class SupportTicketSystem {
  static async createTicket(ticketData) {
    const ticket = {
      id: this.generateTicketId(),
      title: ticketData.title,
      description: ticketData.description,
      priority: ticketData.priority || 'medium',
      category: ticketData.category,
      reporter: ticketData.reporter,
      assignee: null,
      status: 'open',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      comments: []
    };
    
    // è‡ªå‹•åˆ†é…å·¥å–®
    ticket.assignee = await this.autoAssignTicket(ticket);
    
    // å„²å­˜å·¥å–®
    await this.saveTicket(ticket);
    
    // ç™¼é€é€šçŸ¥
    await this.notifyAssignee(ticket);
    
    return ticket;
  }
  
  static async autoAssignTicket(ticket) {
    const assignmentRules = {
      'technical_issue': ['tech-team'],
      'content_issue': ['content-team'],
      'user_management': ['admin-team'],
      'security_issue': ['security-team']
    };
    
    const eligibleTeams = assignmentRules[ticket.category] || ['admin-team'];
    
    // æ‰¾åˆ°å·¥ä½œé‡æœ€å°‘çš„åœ˜éšŠæˆå“¡
    let assignee = null;
    let minWorkload = Infinity;
    
    for (const team of eligibleTeams) {
      const members = await this.getTeamMembers(team);
      
      for (const member of members) {
        const workload = await this.getMemberWorkload(member.id);
        if (workload < minWorkload) {
          minWorkload = workload;
          assignee = member.id;
        }
      }
    }
    
    return assignee;
  }
  
  static generateTicketId() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    return `TICKET-${timestamp}-${random}`.toUpperCase();
  }
}

// æ”¯æ´å·¥å–® API
// src/pages/api/support/tickets.ts
export async function POST({ request }) {
  try {
    const ticketData = await request.json();
    
    // é©—è­‰å·¥å–®è³‡æ–™
    const validation = validateTicketData(ticketData);
    if (!validation.valid) {
      return new Response(JSON.stringify({ error: validation.errors }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    // å»ºç«‹å·¥å–®
    const ticket = await SupportTicketSystem.createTicket(ticketData);
    
    return new Response(JSON.stringify(ticket), {
      status: 201,
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('Failed to create support ticket:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

function validateTicketData(data) {
  const errors = [];
  
  if (!data.title || data.title.trim().length < 5) {
    errors.push('æ¨™é¡Œè‡³å°‘éœ€è¦ 5 å€‹å­—å…ƒ');
  }
  
  if (!data.description || data.description.trim().length < 20) {
    errors.push('æè¿°è‡³å°‘éœ€è¦ 20 å€‹å­—å…ƒ');
  }
  
  const validCategories = ['technical_issue', 'content_issue', 'user_management', 'security_issue'];
  if (!data.category || !validCategories.includes(data.category)) {
    errors.push('è«‹é¸æ“‡æœ‰æ•ˆçš„å•é¡Œé¡åˆ¥');
  }
  
  const validPriorities = ['low', 'medium', 'high', 'urgent'];
  if (data.priority && !validPriorities.includes(data.priority)) {
    errors.push('è«‹é¸æ“‡æœ‰æ•ˆçš„å„ªå…ˆç´š');
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
```

## è¯ç¹«è³‡è¨Š

### æŠ€è¡“æ”¯æ´

- **ç³»çµ±ç®¡ç†å•é¡Œ**ï¼šadmin@your-org.com
- **æŠ€è¡“é–‹ç™¼å•é¡Œ**ï¼štech@your-org.com
- **å®‰å…¨ç›¸é—œå•é¡Œ**ï¼šsecurity@your-org.com

### ç·Šæ€¥è¯ç¹«

- **24å°æ™‚æŠ€è¡“ç†±ç·š**ï¼š+886-2-xxxx-xxxx
- **ç·Šæ€¥äº‹ä»¶å›å ±**ï¼šemergency@your-org.com
- **å®‰å…¨äº‹ä»¶å›å ±**ï¼šsecurity-incident@your-org.com

### æ–‡ä»¶èˆ‡è³‡æº

- **æŠ€è¡“æ–‡ä»¶**ï¼šhttps://docs.your-org.com
- **API æ–‡ä»¶**ï¼šhttps://api-docs.your-org.com
- **ç‹€æ…‹é é¢**ï¼šhttps://status.your-org.com

---

**æ‰‹å†Šç‰ˆæœ¬**ï¼šv1.0.0 | **æœ€å¾Œæ›´æ–°**ï¼š2025å¹´1æœˆ | **é©ç”¨ç³»çµ±ç‰ˆæœ¬**ï¼šv1.0.0+